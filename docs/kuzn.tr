.so 2syktsu.tmac
.\"nr HI 3*\n[PI]
.ds M \(Fo
.ds U \(Fc
.ds DS "дата, подпись
.ds - \(em
.ds _ \(en
.ds FGCAPBG Рис.
.ds FGCAPSM рис.
.ds FGNRSEP .
.char \[star] "\v'-0.2m'\(**\v'0.2m'
.
.
.
.TC
.U1 "Список использованных определений"
.PP
В настоящей работе применяются следующие термины с соответствующими определениями:
.sp 
\*BАлгоритм зашифрования\*P 
(encryption algorithm) \(em алгоритм, реализующий
зашифрование, т.е. преобразующий открытый текст в шифртекст.
.sp
\*BАлгоритм расшифрования\*P 
(decryption algorithm) \(em алгоритм, реализующий
расшифрование, т.е. преобразующий шифртекст в открытый текст.
.sp
\*BБазовый блочный шифр\*P 
(basic block cipher) \(em блочный шифр, реализующий при
каждом фиксированном значении ключа одно обратимое отображение множества
блоков открытого текста фиксированной длины в блоки шифртекста такой же длины.
.sp
\*BБлочный шифр\*P 
(block cipher) \(em шифр из класса симметричных
криптографических методов, в котором алгоритм зашифрования применяется к
блокам открытого текста для получения блоков шифртекста.
.sp 
\*BЗашифрование\*P 
(encryption) \(em обратимое преобразование данных с помощью
шифра, которое формирует шифртекст из открытого текста.
.sp 
\*BИтерационный ключ\*P 
(round key) \(em последовательность символов, вычисляемая
в процессе развертывания ключа шифра, и определяющая преобразование на
одной итерации блочного шифра.
.sp 
\*BКлюч\*P 
(key) \(em изменяемый параметр в виде последовательности символов,
определяющий криптографическое преобразование.
.sp 
\*BРазвертывание ключа\*P 
(key schedule) \(em вычисление итерационных ключей из
ключа шифра.
.sp 
\*BСимметричный криптографический метод\*P 
(symmetric cryptographic technique) \(em Криптографический метод,
использующий один и тот же ключ для преобразования,
осуществляемого отправителем, и преобразования, осуществляемого получателем.
.sp 
\*BШифр\*P
(cipher) \(em криптографический метод, 
используемый для обеспечения конфиденциальности данных, 
включающий алгоритм зашифрования и алгоритм
расшифрования.
.sp 
\*BШифртекст\*P
(ciphertext) \(em данные, полученные в результате зашифрования
открытого текста с целью скрытия его содержания.
.sp 
\*BS-блок\*P
( substitution box or S-box) \(em  замещает маленький блок входных бит на
другой блок выходных бит. Эта замена должна быть взаимно однозначной,
чтобы гарантировать обратимость.
Назначение S-блока заключается в нелинейном преобразовании, 
что препятствует проведению линейного криптоанализа.
.sp 
\*BP-блок\*P
(permutation box or P-box) \(em блок меняет местами все биты входных данных.
Важным качеством P-блока является возможность распределить данные между входами как можно больших последующих блоков.
.
.U1 "Список использованных обозначений"
.PP
В настоящей работе применяются следующие обозначения:
.
.
.U1 "Введение"
.PP
В 2015 году в России были приняты новые стандарты на блочное шифрование в РФ
- ГОСТ Р 34.12-2015 \*QБлочныйе шифры\*U и 
ГОСТ Р 34.13-2015 \*QРежимы работы блочных шифров\*U.
ГОСТ Р 34.12-2015 был принят взамен старого доброго ГОСТ 28147-89.
В данном ГОСТ-е помимо старого алгоритма с длиной блока 64 бита, 
который назвали \*QМагма\*U,
был введён новый шифр с длиной блока уже 128 бит и длиной ключа 256 бит, который получил название \*QКузнечик\*U.
.PP
ГОСТ Р 34.13-2015 был принят взамен старого ГОСТ ИСО/МЭК 10116-93. 
Вотличие от старого, новый ГОСТ содержит дополнительные режимы шифровани, отсутсвовавшие в старом ГОСТ-е. 
Так же, оба ГОСТ-а имеют намного более приемлимое качество,
более полную информацию об испонении и понятные примеры тестовых векторов.
.PP
В условиях новизны стандартов, было решено, что подробное изучение и программная реализация этих алгоритмов и режимов их работы станут актуальной задачей на момент выполнения работы.
.PP
Целью данной работы является программная реализация алгоритма блочного шифрования с длиной блока 128 бит \*QКузнечик\*U в режимах работы
\*Qпростой замены\*U и \*Qобратной связи по шифртексту\*U.
.PP
\*BПостановка задачи\*P
.PP
Для достидения поставленной цели необходимо решить следующие задачи:
.RS
.PI \(bu
Изучение теоретической базы.
.PI \(bu
Подробное изучение ГОСТ 34.12-2015 и ГОСТ 34.13-2015.
.PI \(bu
Программная реализация выбранного алгоритма и режимов работы.
.RE
.PP
\*BВыбор метода реализации задач:\*P
.PP
Основной задачей данной работы является программная реализация выбранного алгоритма.
Инструментом для решения основной задачи был выбран язык программирования СИ.
Основной платформой для программной реализации была выбрана ОС Linux.
Интерфейс взаимодействия с пользователем был выполнен в виде аргументов командной строки.
.H1 "Теоретические основы"
.
.H2 "Методы построения блочных шифров"
.PP
Воснове алгоритма \*QКузнечик\*U лежат два основных метода посторенияблочных шифров:
метод \*Qсетей Фейстеля\*U и метод \*QSP-сетей\*U,
предложенные в 1971 году Хорстом Фейстелем. 
Рассмотри подробнее эти методы.
.H3 "SP-сеть"
.PP
SP-сеть (Substitution-Permutation network,
подстановочно-перестановочная сеть) \(em разновидность блочного шифра, предложенная в 1971 году Хорстом Фейстелем.
В простейшем варианте представляет собой \*Qсэндвич\*U из слоёв двух типов,
используемых многократно по очереди. Первый тип слоя \(em P-слой, 
состоящий из P-блока большой разрядности, за ним идёт второй тип слоя \(em S-слой, представляющий собой большое количество S-блоков малой разрядности,
потом опять P-слой и т. д.
Первым криптографическим алгоритмом на основе SP-сети был \*QЛюцифер\*U (1971).
В настоящее время из алгоритмов на основе SP-сетей широко используется AES (Rijndael).
.PP
.FG sp1.eps fig:sp "Пример SP-сети с 3 раундами"
.PP
Рассмотрим работу сети на простом примере, содержащем всего 3 раунда(Рис.1)
Шифр на основе SP-сети получает на вход блок и ключ и совершает несколько
чередующихся раундов, состоящих из чередующихся стадий подстановки (S-блок) и стадий перестановки (P-блок).
Для достижения безопасности достаточно одного S-блока,
но такой блок будет требовать большого объёма памяти.
Поэтому используются маленькие S-блоки, смешанные с P-блоками.
Нелинейная стадия подстановки перемешивает биты ключа с битами открытого текста, создавая конфузию Шеннона.
Линейная стадия перестановки распределяет избыточность по всей структуре данных, порождая диффузию[1].
.sp 10
.
.H3 "Сеть Фейстеля"
.PP
Сеть Фейстеля(Feistel network) \(em сеть, состоящая из ячеек,
называемых ячейками Фейстеля. 
На вход каждой ячейки поступают данные и ключ.
На выходе каждой ячейки получают изменённые данные и изменённый ключ.
Все ячейки однотипны, и говорят, 
что сеть представляет собой определённую многократно повторяющуюся (итерированную) структуру. 
Ключ выбирается в зависимости от алгоритма шифрования/расшифрования и меняется при переходе от одной ячейки к другой.
При шифровании и расшифровании выполняются одни и те же операции,
отличаясь только порядком ключей. 
Ввиду простоты операций сеть Фейстеля легко реализовать как программно, так и аппаратно.
Большинство современных блочных шифров (DES, RC2, RC5, RC6, Blowfish, FEAL, CAST-128, TEA, XTEA, XXTEA и др.) используют сеть Фейстеля в качестве основы[1].
.FG Feistel.eps fig:sp "Пример шифрования с использованием сети Фейстеля"
.PP
Расммотрим работу сети Фейстеля на простом примере зашифрования блока текста(Рис.2).
Алгоритм состоит из повторяющихся раундов, в каждом из которых выполняются следующие действия:
.RS
.PI 1.
Входной блок разбивается на левую (L) и правую (R) части.
.PI 2.
Левая часть и раундовый ключ (K) поступают на вход функции шифрования(F).
.PI 3.
Правая часть складывается по модулю 2 с результатом работы функции шифрования.
.PI 4.
Происходит конкатенация обеих ветвей и циклический сдвиг вправо.
.RE
.H2 "Конечные поля"
.PP
Конечное поле, или поле Галуа \(em поле, состоящее из конечного числа элементов.
Число элементов в поле называется его порядком. 
Конечное поле обычно обозначается GF($q$) (сокращение от Galois field) и называется полем Галуа порядка $q$.
C точностью до изоморфизма конечное поле полностью определяется его порядком,
который всегда является степенью какого-нибудь простого числа,
то есть $q = p sup n$, где $p$ \(em простое число, 
называемое так же основанием поля, а $n$ \(em любое натуральное число.
При этом $p$  будет являться характеристикой этого поля.
Понятие конечного поля используется, в теории чисел, теории групп,
алгебраической геометрии, криптографии.
.PP
Элементы поля Галуа можно складывать и умножать и т.д., но эти операции
отличаются от тех, которые используются для чисел. 
В данном параграфе будут описаны основные математические операции в полях Галуа.
.
.H3 "Сложение и вычитание"
.LA h!10.1
.PP
Сложение и вычитание 2 элементов в поле Галуа достигается за счет
сложения и вычитания коэффициентов полиномов по модулю его основания соответственно. 
В дальнейшем все операции будут выполняться в поле GF($2 sup 8$). 
Таким образом, в рамках данной работы, они эквивалентны операции XOR: 
$1 ~ \[c+] ~ 1 = 0$, $1  ~ \[c+] ~  0 = 1$, $0 ~ \[c+] ~ 0 = 0$.
.PP
Рассмотри для примера операцию сложения.
Добавление конечных элементов поля Галуа можно охарактеризовать как сложение по модулю 2
соответствующих битов в байте. Для 2 байтов $[ a sub 7 , a sub 6, a sub 5 , a sub 4 , a sub 3 , a sub 2 , a sub 1 , a sub 0 ]$, и  $[ b sub 7 , b sub 6 , b sub 5 , b sub 4 , b sub 3 , b sub 2 , b sub 1 , b sub 0 ]$ суммой будет являться байт  $[ с sub 7 , с sub 6, с sub 5 , с sub 4 , с sub 3 , с sub 2 , с sub 1 , с sub 0 ]$, где $c sub i = a sub i$  \[c+]  $b sub i$.
.PP
Следующие выражения эквивалентны друг другу:
.EQ
mark {(x sub 6 + x sub 4 + x sub 2 + x + 1) + (x sub  7 + x + 1) = x sub 7 + x sub 6 + x sub 4 + x sub 2 ~{"	(Полиноминальная запись)"}~}
.EN
.EQ
  lineup {[01010111] ~ \[c+] ~ [10000011] = [11010100]~{"			(Бинарная запись)"}~}
.EN
.EQ
  lineup {[57] ~ \[c+] ~ [83] = [d4]~{"					(Шестнадцатиричная  запись)"}~}
.EN
.H3 "Умножение"
.PP
В полиномиальном представлении, умножение в поле Галуа GF($2 sup 8$) (обозначается $times$) 
соответствует умножению полиномов по модулю неприводимого полинома степени 8(обозначим $m(x)$). Полином называется неприводимым, если
его нельзя разложить на нетривиальные (неконстантные) многочлены.
.
Например, $[57]  times [83] = [c1]$, потому что:
.
.EQ
mark (x sup 6 + x sup 4 + x sup 2 + x + 1) + (x sup  7 + x + 1) =
.EN
.
.EQ
lineup = x sup 13 + x sup 11 + x sup  9 + x sup  8 + x sup 7 + x sup 5 + x sup 3 + x sup  2 + x + x sup  6 + x sup  4 + x sup 2 + x + 1 = 
.EN
.
.EQ 
lineup = x sup 13 + x sup 11 + x sup  9 + x sup 8 + x sup 6 + x sup 5 + x sup 4 + x sup 3 + 1
.EN
.
и  $( x sup 13 + x sup 11 + x sup  9 + x sup 8 + x sup 6 + x sup 5 + x sup 4 + x sup 3 + 1) \0  roman {~mod~} \0 (x sup 8 + x sup 4 + x sup 3 + x + 1) = x sup 7 + x sup 6 + 1 $
.PP
Сокращение на $m(x)$ гарантирует, что результатом будет полином
степени меньше 8, и он может быть представлен байтом. 
.PP
Операция деления заключается в следующем:
.PP
Для любого ненулевого двоичного полинома $b(х)$ степени меньше  8, можно найти обратный многочлен  $b sup -1 (х)$, с помощью расширеного алгоритма Евклида, используя полиномы $a(x)$ и $c(x)$:
.
.EQ \*(EX
b(x)a(x) + m(x)c(x) = 1
.EN
.
.PP
Но $a(x) times b(x)$ mod $m(x) = 1$ значит:
.
.EQ
b sup -1 (x) = a(x) roman {~mod~}  m(x).
.EN
.PP
Для упрощения и ускорения операций умножения и деления, 
составляют специальные логарифмические таблицы,
исходя из следующего равенства:
.EQ
ab = g sup {log sub g (ab)} = g sup {log sub g a + log sub g b } 
.EN
.PP 
Где $g$ выбирается из т.н.\*Qгенерирующих\*U полиномов поля.
Подобноые полиномы являются частями всех конечных полей.
Их главное свойство \(em  неприводимость[2].
.
.
.
.H1 "ГОСТ-Р 34.12-2015. Алгоритм \*QКузнечик\*U"
.PP
Для решения поставленной задачи, в данной работе будет рассмотрен лишь алгоритм с длиной блока 128 бит, получивший название \*QКузнечик\*U".
В отличие от ГОСТ 28147-89 новый шифр представляет собой не сеть Фейстеля,
а SP-сеть. Шифрование основано на последовательном применении нескольких однотипных раундов, 
каждый из которых содержит три преобразования: сложение с раундовым ключом,
преобразование блоком подстановок и линейное преобразование. 
Для того, чтобы понять работу алгоритма, разберём все преобразования, 
применяемые к блоку входного текста на каждом раунде на конкретном примере.
.
.
.H2 "Преобразования"
.PP
Все преобразования будут сопровождаться примерами со следующими параметрами:
.sp 0
$a$ = 1122334455667700ffeeddccbbaa9988 \(em входной блок текста,
.sp 0
$k$ = 99BB99FF99BB99FFFFFFFFFFFFFFFFFF \(em раундовый ключ.
.PP
Вначале 128-битный входной вектор очередного раунда складывается побитно с раундовым ключом(Рис.3):
.EQ
X[k](a) = k ~ \[c+] ~ a,~ где
.EN
.sp 0
\h'185p'k \(em раундовый ключ,
.sp 0
\h'180p'а \(em входной блок текста.
.FG X.eps fig:X "Пример X-преобразования"
.PP
Затем результат подвергается нелинейному биективному преобразованию,
таблица для которого определена в ГОСТ-е.
Работает оно следующим образом:
.PP
128-битный вектор после сложения по модулю два побайтно преобразовывается в десятичный вид, 
тем самым определяется позиция байта в таблице подстановок (S-блок),
затем с этой позиции считывается число в десятичном виде и преобразуется
назад в шестнадцатеричный вид. 
Например, шестнадцатеричному числу 99 соответствует десятичное 153.
Элемент с номером 153 в таблице подстановок имеет значение 232,
что соответствует шестнадцатеричному E8(Рис.4). 
Данное преобразование обозначено в ГОСТ-е как $S$.
.EQ
S(a) = S( a sub 15 || ... || a sub 0 ) = 
\[*p] ( a sub 15 ) || ... || \[*p] ( a sub 0 ) ,
.EN
.EQ
где ~ a = a sub 15 || ... || a sub 0 , 
 ~ \[*p] ~ \(em ~ операция ~ подстановки.
.EN
.FG S.eps fig:S "Пример S-преобразования"
.PP
Следующим этапом зашифрования является линейное преобразование,
выполняемое с использованием линейного регистра сдвига с обратной связью.
Работает оно следующим образом: очередной байт входного юлока считывается,
затем складывается по модулю два с результатами умножаения других байтов входного блока в поле на коэффициенты 148, 32, 133, 16, 194,
192, 1, 251, 1, 192, 194, 16, 133, 32, 148, 1 в зависимости от номера байта.
Регистр сдвигается в сторону младшего байта на один байт. 
Полученное число в шестнадцатеричном виде записывается на место старшего байта.
Регистр сдвигается и перезаписывается 16 раз.
Данное преобразование обозначено в ГОСТ-е как $S$.
Схематическое изображение работы L-преобразования показано на рисунке 5,
а пример его работы на рисунке 6.
.FG P_shem.eps fig:S "Схема L-преобразования"
.FG P.eps fig:S "Пример L-преобразования"
.EQ
R(a) = R( a sub 15 || ... || a sub 0 ) = 
l ( a sub 15 ... a sub 0  ) a sub 15 || ... || a sub 1  ,
.EN
.EQ
L(a) = R sup 16 (a)
.EN
.EQ
где ~ a = a sub 15 || ... || a sub 0 ~ \(em ~ блок ~ входного ~ тескта ~
.EN
.PP
Результатом L-преобразования будет следующий 128-битный вектор
$a = E297B686E355B0A1CF4A2F9249140830$.
Это результат работы первого раунда алгоритма, таким же образом будут проходить последующие 8 раундов,
результаты их работы можно посмотреть в описании стандарта. Схематическое изображение одного раунда можно увидеть на рисунке 7.
Заключительный 10 раунд включает в себя только X-преобразование результатов работы 9 раундов и ключа 10 раунда.
.FG raund.eps fig:raund "Схема одного раунда преобразования"
.
.
.H2 "Выработка раундовых ключей"
.PP
Рассмотрим теперь процедуру генерации раундовых ключей из мастер-ключа.
Первые два получаются разбиением мастер-ключа пополам.
Далее для выработки очередной пары раундовых ключей используется 8 итераций сети Фейстеля,
где, в свою очередь, в качестве раундовых ключей используется счетчиковая последовательность,
прошедшая через линейное (L) преобразование алгоритма:
.EQ
F[k](a sub 1 , a sub 0 ) = (LSX[k] (a sub 1 ) ~ \[c+] ~ a sub 0 , a sub 1 ) ,
.EN
.EQ
где ~ k ~ \(em ~ раундовый ~ ключ ~ алгоритма ~ развёртки ~ ,
.EN
.EQ
a sub 0 , a sub 1 ~ \(em ~ входные блоки текста для очередного раунда алгоритма развёртки
.EN
.EQ
C sub i = L (i), ~ i = 1,~2,..,~32.
.EN
.EQ
(K sub {2i + 1}, ~ K sub {2i + 2} ) = 
F [C sub {8(i - 1) + 8 } ] ... 
F [C sub {8(i - 1) + 1 } ] (K sub {2i - 1}, ~ K sub {2i} ), ~ i = 1,~2,~3,~4.
.EN
.PP
Раунд ключевой развертки можно изображён на рисунке 8:
.FG key_raund.eps fig:key_raund "Схема одного раунда алгоритма развёртки ключей"
.PP
А вся процедура выработки пары раундовых ключей изображена на рисунке 9.
.FG key_all.eps fig:keu_all "Схема выработки очередной пары раундовых ключей"
.
.
.H2 "Шифрование и расшифрование"
.PP
В результате, шифрование одного 128-битного входного блока описывается следующим уравнением:
.EQ
E sub {K sub 1 ... K sub 10 } (a) = X[K sub 10 ]LSX[K sub 9 ] ... LSX [K sub 1 ] (a) 
.EN
.PP
В виде блок-схемы шифрование представлено на рисунке 10.
.FG cipher.eps fig:cipher "Схема шифрования одного блока"
.PP
Расшифрование реализуется обращением базовых преобразований и применением их в обратном порядке[3]:
.EQ
D sub {K sub 1 ... K sub 10 } (a) = X[K sub 1 ]S sup -1 L sup -1 X[K sub 2 ] ...
S sup -1 L sup -1 X [K sub 10 ] (a) 
.EN
.
.
.
.H1 "ГОСТ 34.13-15 \*QРежимы работы блочных шифров\*U"
.PP
Данный стандарт содержит в себе описание основных режимов работы современных
блочных шифров, а так же используемые в реализации дополнительные операции.
.PP
В стандарте используются следующие термины с соответствующими определениями:
.sp 
\*Bбазовый блочный шифр\*P 
(basic block cipher) \(em  блочный шифр, реализующий
при каждом фиксированном значении ключа одно обратимое отображение
множества блоков открытого текста фиксированной длины в блоки шифртекста
такой же длины.
.sp 
\*Bдополнение\*P
(padding) \(em приписывание дополнительных бит к строке бит.
.sp 
\*Bзацепление блоков \*P
(block chaining) \(em шифрование информации таким
образом, что каждый блок шифртекста криптографически зависит от предыдущего
блока шифртекста.
.sp 
\*Bзимитовставка \*P
(message authentication code) \(em строка бит фиксированной
длины, полученная применением симметричного криптографического метода к
сообщению, добавляемая к сообщению для обеспечения его целостности и
аутентификации источника данных.
.sp 
\*Bсинхропосылка \*P
(initializing value) \(em комбинация знаков, передаваемая по
каналу связи и предназначенная для инициализации алгоритма шифрования.
.sp 
\*Bсчётчик\*P
(counter) \(em Строка бит длины, равной длине блока блочного шифра,
используемая при шифровании в режиме гаммирования.
.
.
.H2 "Вспомогательные операции"
.
.H3 "Дополнение сообщения"
.PP
Некоторые режимы работы блочных шифров требуют,чтобы длина сообщения была
кратна некоторой величине $l$(длина входного блока). В последнем случае при работе с сообщениями
произвольной длины необходимо применение процедуры дополнения сообщения до
требуемой длины. Ниже приведены три процедуры дополнения[4]. 
$P$ в дальнейшем обозначает исходное собщение, $P$\u\s-4*\s0 \d.
.PP
\*BПроцедура 1\*P
.PP
Пусть $r = |P|$ mod $l$, тогда:
.EQ
P sup * = left { lpile {
P , ~ если ~ r = 0
above 
P || 0 sup {l - r}, ~ иначе}
.EN
.PP
Описанная процедура в некоторых случаях не обеспечивает
однозначного восстановления исходного сообщения, 
а потому, для однозначного восстановления необходимо дополнительно знать 
длину исходного сообщения[4].
.PP
\*BПроцедура 2\*P
.PP
Пусть $r = |P|$ mod $l$, тогда:
.EQ
P sup * = P || 1 || 0 sup {l-r-1}.
.EN
Данная процедура обеспечивает однозначное восстановление
исходного сообщения. При этом если длина исходного сообщения кратна $l$,
то длина дополненного сообщения будет увеличена на длину блока шифра[4].
.PP
\*BПроцедура 3\*P
.PP
Пусть $r = |P|$ mod $l$, тогда:
В зависимости от значения $r$ возможны случаи:
.RS
.PI \(bu
если $r = n$, то последний блок не изменяется $P$\u\s-4*\s0\d = $P$
.PI \(bu
если r < n, то применяется процедура 2.
.RE
.PP
Данная процедура обязательна для режима выработки имитовставки и не
рекомендуется для использования в других режимах[4].
.
.H3 "Синхропосылка"
.PP
В некоторых режимах работы используются величины, начальное значение
которых вычисляется на основании синхропосылки $IV$;
Во всех описываемых в настоящем стандарте режимах работы не требуется обеспечение
конфиденциальности синхропосылки.
Вместе с тем процедура выработки синхропосылки должна удовлетворять одному из следующих требований.
.RS
.PI \(bu
Значения синхропосылки для режимов простой замены с зацеплением и
гаммирования с обратной связью по шифртексту необходимо выбирать
случайно, равновероятно и независимо друг от друга из множества всех
допустимых значений. В этом случае значение каждой используемой
синхропосылки $IV$ должно быть непредсказуемым 
(случайным или псевдослучайным): зная значения всхе других используемых
синхропосылок, значение $IV$ нельзя определить с вероятностью большей,
чем 2\u\s-4 \fI-|IV|\fP\s0\d.
.PI \(bu
Все значения синхропосылок, выработанных для зашифрования на одном и
том же ключе в режиме гаммирования, должны быть уникальными, т.е.
попарно различными. Для выработки значений синхропосылок может быть
использован детерминированный счетчик.
.PI \(bu
Значение синхропосылки для режима гаммирования с обратной связью по
выходу должно быть либо непредсказуемым (случайным или псевдослучайным),
либо уникальным[4].
.RE
.
.H3 "Процедура усечения"
.PP
В некоторых режимах используется усечение строк длины $n$ до строк длины
$s$. В таких случаях используется функция $Т sub s$,
закюлающаяся во взятии бит с большими номерами[4].
.
.
.H2 "Режимы работы алгоритмов блочного шифрования"
.PP
В рамках данной работы будут рассмотрены только два режима работы шифров,
реализованные программно:
.RS
.PI \(bu
Режим простой замены
.PI \(bu
Режим гаммирования с обратной связью по шифртексту
.RE
.PP
Описание остальных режимов работы Вы можете глянуть в приложенном ГОСТ 34.13-15.
.PP
Далее будут употребляться следующие обозначения:
.RS
.PI 
$ e sub k $ \(em базовый алгоритм зашифрования.
.PI 
$ d sub k $ \(em базовый алгоритм расшифрования.
.RE
.
.H3 "Режим простой замены"
.PP
Длина сообщений, зашифровываемых в режиме простой замены, должна
быть кратна длине блока базового алгоритма блочного шифрования $n$, поэтому, при необходимости, 
к исходному сообщению должна быть предварительно применена процедура дополнения.
Зашифрование (расшифрование) в режиме простой замены заключается в
зашифровании (расшифровании) каждого блока текста с помощью базового
алгоритма блочного шифрования[4].
.PP
\*BЗашифрование\*P
.PP
Открытый и, при необходимости, дополненный текст $|P| = n*q$ представляется в виде:
$P = P sub 1 || ... || P sub i || ... ||P sub q , ~ i = 1, 2, ..., q.$
Блоки шифртекста вычисляются по следующему правилу:
.EQ
C sub i = e sub k (P sub i ) , ~ i = 1,2,..,q. 
.EN
.PP
Результирующий шифртекст имеет вид:
.EQ
C = C sub 1 || C sub 2 ||...|| C sub q. 
.EN
Зашифрование в режиме простой замены проиллюстрировано на рисунке 11
.FG e.eps fig:e "Схема зашифрования в режиме простой замены"
.sp
.PP
\*BРасшифрование\*P
.PP
Шифртекст представляется в виде: $ C = C sub 1 ||C sub 2 ||...||C sub q $.Блоки открытого текста вычисляются по следующему правилу:
.EQ
P sub i = d sub k (C sub i ) , ~ i = 1,2,..,q. 
.EN
Исходный (дополненный) открытый текст имеет вид:
.EQ
P = P sub 1 || P sub 2 ||...|| P sub q. 
.EN
.PP
Если к исходному открытому тексту была применена процедурадополнения, 
то после расшифрования следует произвести обратную процедуру. 
Для однозначного восстановления сообщения может потребоваться знание длины исходного сообщения[4].
.PP
Расшифрование в режиме простой замены проиллюстрировано на рисунке 12.
.FG d.eps fig:d "Схема расшифрования в режиме простой замены"
.H3 "Режим гаммирования с обратной связью по шифртексту"
.PP
Параметрами режима гаммирования с обратной связью по шифртексту
являются целочисленные величины $s$ и $m$ , $0 < s <= n, ~ n <= m $.
.PP
В конкретной системе обработки информации на длину сообщения $P$ может
как накладываться ограничение $|P| = s*q$, так и не накладываться никаких
ограничений. В случае если такое ограничение накладывается,
к исходному сообщению, при необходимости, должна быть предварительно применена процедура дополнения[4].
.PP
При шифровании на одном ключе для каждого отдельного открытого текста
используется значение непредсказуемой (случайной или псевдослучайной) синхропосылки $IV$.
.PP
При шифровании в режиме гаммирования с обратной связью по шифртексту
используется двоичный регистр сдвига $R$ длины $m$. Начальным заполнением
регистра является значение синхропосылки $IV$.
.PP
Зашифрование в режиме гаммирования с обратной связью по шифртексту
заключается в покомпонентном сложении открытого текста с гаммой шифра,
которая вырабатывается блоками длины $s$. При вычислении очередного блока
гаммы выполняется зашифрование $n$ разрядов регистра сдвига с большими
номерами базовым алгоритмом блочного шифрования с последующим усечением.
Затем заполнение регистра сдвигается на $s$ разрядов в сторону разрядов с
большими номерами, при этом в разряды с меньшими номерами записывается
полученный блок шифртекста, являющийся результатом покомпонентного сложения
гаммы шифра и блока открытого текста[4].
.PP
\*BЗашифрование\*P
.PP
Открытый текст $P$ представляется в виде $P = P sub 1 ||P sub 2 ||...||P sub q,$
Блоки шифртекста вычисляются по следующему правилу:
.EQ
R sub 1 = IV,
.EN
.EQ
left { lpile {
C sub i = P sub i ~ \[c+] ~  T sub s ( e sub k ( MSB sub n ( R sub i ) ))),
above 
R sub {i+1} = LSB sub {m-s} ( R sub i ) || C sub i,
}
.EN
.EQ
i = 1, ~ 2,..,q-1,
.EN
.EQ
C sub q = P sub q ~ \[c+] ~  T sub r ( e sub k ( MSB sub n ( R sub q ) ))),
.EN
.PP
Результирующий шифртекст имеет вид:
.EQ
C = C sub 1 ||C sub 2 ||...||C sub q .
.EN
.PP
Зашифрование в режиме гаммирования с обратной связью по шифртексту
проиллюстрировано на рисунке 13.
.FG OFBen.eps fig:OFBen "Схема зашифрования в режиме гаммирования с обратной связью по шифртексту"
.PP
\*BРасшифрование\*P
.PP
Шифртекст представляется в виде: $C = C sub 1 ||C sub 2 ||...||C sub q$.
Блоки открытого текста вычисляются по следующему правилу:
.EQ
R sub 1 = IV,
.EN
.EQ
left { lpile {
P sub i = C sub i ~ \[c+] ~  T sub s ( e sub k ( MSB sub n ( R sub i ) ))),
above 
R sub {i+1} = LSB sub {m-s} ( R sub i ) || C sub i,
}
.EN
.EQ
i = 1, ~ 2,..,q-1,
.EN
.EQ
P sub q = C sub q ~ \[c+] ~  T sub r ( e sub k ( MSB sub n ( R sub q ) ))),
.EN
.PP
Исходный открытый текст имеет вид:
.EQ
P = P sub 1 ||P sub 2 ||...||P sub q .
.EN
.PP
Если к исходному открытому тексту была применена процедура
дополнения, 
то после расшифрования следует произвести обратную процедуру. 
Для однозначного восстановления сообщения может потребоваться знание длины исходного сообщения[4].
.PP
Расшифрование в режиме гаммирования с обратной связью по шифртексту
проиллюстрировано на рисунке 14.
.FG OFBde.eps fig:OFBde "Схема расшифрования в режиме гаммирования с  обратной связью по шифртексту"
.
.
.
.H1 "Программная реализация"
.PP
В конечном итоге была написана программа, 
код которой приведён в приложении к данной работе.
Интерфейсом программы, как было отмечено выше, 
выбраны аргументы командной строки.
Ниже приведён вывод вспомогательного сообщения при использовании недекларироанного флага.
.KS
.sp 0.5v
.in \n[PI]u
.nf
.ta T 0.3m
.vs -4p
.CW
Usage: kuzn_chiper [OPTIONS] [FILE]
Transform standard input or predefined input file by GOST 34.12-15 
to standard output or predefined output file.

Options: 
  -e <encrypt>		encrypt input 
  -d <decrypt>          decrypt input
  -k <secret-key-file>  secret key file(hex)
  -s <simple mode>      work in simple mode
  -t <OFB mode>      	work in Outtext FeedBack mode 
  with inital gamma synchronisation file (hex)
  -s <sinple mode>      
  -i <input-file>       input file
  -o <output-file>      output file

  If no FILE provided, then reads standard input. 

Examples: 
  kuzn_chiper -e -k key -t sync -i /etc/passwd > passwd.encr

.sp 0.5v
.PL
.ce 1
\*B Вывод вспомогательного сообщения\*P
.sp 1.5v
.KE
.PP
Из вспомогательного сообщения видно,
что режим работы шифратора однозначно выставляется с помошью соответствующих аргументов.
Единственным обязательным аргументом является указание файла с ключом.
Остальные аргументы имеют стандартные значения. 
Стандартно шифратор работает в режиме простой замены, исходный текст читается со стандартного ввода, а шифртекст записывается в станартный вывод.
.PP
Структурно программа состоит из центрального файла \f(CWmain.c\fP, 
в котором обрабатываются аргументы программы, файла \f(CWkuzn.c\fP,
в котором реализованы все функции шифорвания текста и файла \f(CWgf.c\fP,
в котором реализованы все испоьзующиеся функции работы с полем Галуа.
.PP
В заголовочном файле \f(CWkuzn.h\fP находятся объявления использующиихся функций из файла \f(CWkuzn.c\fP.
.KS
.sp 0.5v
.in \n[PI]u
.nf
.ta T 0.3m
.vs -4p
.CW
void Xfunc(uint8_t* block, uint8_t* raund_key);
void Cfunc(int i, uint8_t *C);
void Ffunc(uint8_t *C, int i, uint8_t[10][16]);
void efunc(uint8_t *block, uint8_t[10][16]);
void dfunc(uint8_t *block, uint8_t[10][16]);

int bl_gen_en(uint8_t *block, FILE *input_f);
int bl_gen_de(uint8_t *block, FILE *input_f);
int sync_gen(uint8_t *sync, FILE *sync_f);
int keys_gen(uint8_t[10][16], FILE *key_f);

int simple_mode_en(uint8_t [10][16], FILE *input_f, FILE *output_f);
int OFB_mode_en(uint8_t[10][16], uint8_t *sync, 
FILE *input_f, FILE *output_f);
int simple_mode_de(uint8_t [10][16], FILE *input_f, FILE *output_f);
int OFB_mode_de(uint8_t[10][16], uint8_t *sync, 
FILE *input_f, FILE *output_f);
.sp 0.5v
.PL
.ce 1
\*B Заголовочный файл kuzn.h\*P
.sp 1.5v
.KE
.PP
В заголовочном файле \f(CWgf.h\fP находятся объявления использующиихся функций из файла \f(CWgf.c\fP.
.KS
.sp 0.5v
.in \n[PI]u
.nf
.ta T 0.3m
.vs -4p
.CW
void gf_tables_init(uint8_t poly);
uint8_t gf_fast_mult(uint8_t a, uint8_t b);.sp 0.5v
.PL
.ce 1
\*B Заголовочный файл gf.h\*P
.sp 1.5v
.KE
.PP
Для демонстрационного показа возможностей шифратора был написан заголовочный файл \f(CWshow.h\fP, содержащий макроподстановки,
включающиеся при определении макроподсстановки \f(CWSHOWMODE\fP единицей.
В случае, если \f(CWSHOWMODE\fP равно 1, чтение шифруемого теста происходит в форматированном виде, 
а на стандартный вывод ошибок подаются промежуточные результаты работы программы, 
демонстрирующие её внутреннюю работу. 
В режиме демонстрационного показа в качестве исходного текста стоит
использовать только тестовые вектора в шестнадцатеричном виде.
.KS
.sp 0.5v
.in \n[PI]u
.nf
.ta T 0.3m
.vs -4p
.CW
#ifndef SHOWMODE
	#define SHOWMODE	1
#endif

#if SHOWMODE == 1
	#define GENERATOR(file, c)	(fscanf(file, "%2x", &c)) == EOF
#else
	#define GENERATOR(file, c)	(c = fgetc(file))== EOF
#endif

#if SHOWMODE == 1
	#define SHOWPRINT(text, m)\\
	do {\\
		fprintf (stderr, #text "\\n"); \\
		int j;\\
		for(j = 0; j < 16; j++)\\
			fprintf (stderr, "%2X  ", m[j]);\\
		fprintf(stderr, "\\n\\n");\\
		
	} while (0)
#endif

#ifndef SHOWPRINT
	#define SHOWPRINT(arg...)
#endif
.PL
.ce 1
\*B Заголовочный файл show.h\*P
.sp 1.5v
.KE
.PP
Стоит так же отметить, что в реализации использвалась 2-я  вспомогательная процедура дополнения сообщения.
.
.
.
.U1 "Заключение"
.PP
В данной работе были выполнены все поставленные задачи:
.RS
.PI \(bu
были углублены знания теории написания криптоалгоритмов;
.PI \(bu
были подробно изучены и частично описаны ГОСТ 34.12-15 и ГОСТ 34.13-15;
.PI \(bu
был программно реализован криптоалгоритм \*QКузнечик\*U 
в режимах простой замены и гаммирования с обратной связью по шифртексту.
.RE
.PP
Данная работа является неплохим подспорьем для изучения как российских стандартов на блочное шифрования,
так и вышеописанного алгоритма \*QКузнечик\*U в частности как для людей,
желающих изучать только теоретический аспект, так и для тех, 
кто желает выполнить практическуюореализацию. 
К сожалению, в \*QСыктывкарском государственном университете имени Питирима Сорокина\*U 
в большинстве случаев предпочтение отдают лишь теоретическому аспекту подобных вопросов.
.U1 "Список использованных источников"
.RS
.PI 1)
W. Diffiee. New directions in cryptography / W. Diffiee, M. Hellman. // IEEE Transactions on Information Theory. \(em New Jersey, 1976.\(em Vol 22(6)\(empp. 644 - 654.
.PI 2) 
Benvenuto C.J. Galois Field in Cryptography.:May 31, 2012
.PI 3) 
Федеральное агентство по техническому регулированию и метрологии. ГОСТ Р 34.12-2015 Информационная технология КРИПТОГРАФИЧЕСКАЯ ЗАЩИТА ИНФОРМАЦИИ Блочные шифры \(em М.:Стандартинформ,2015. \(em 25 с.
.PI 4) 
Федеральное агентство по техническому регулированию и метрологии. ГОСТ Р 34.13-2015 Информационная технология КРИПТОГРАФИЧЕСКАЯ ЗАЩИТА ИНФОРМАЦИИ Режимы работы блочных шифров \(em М.:Стандартинформ,2015. \(em 42 с.
.
.
.
.U1 "Приложения"
